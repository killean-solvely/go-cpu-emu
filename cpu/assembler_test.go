package cpu

import "testing"

func TestAssembler(t *testing.T) {
	program := []string{
		"LOAD R1 1",
		"prelabel:",
		"LOAD R1 R2",
		"LOADM R1 1",
		"STORE R1 1",
		"STORE 1 2",
		"STORE R1 R2",
		"ADD R1 R2",
		"ADD R1 1",
		"SUB R1 R2",
		"SUB R1 1",
		"MUL R1 R2",
		"MUL R1 1",
		"DIV R1 R2",
		"DIV R1 1",
		"MOD R1 R2",
		"MOD R1 1",
		"AND R1 R2",
		"AND R1 1",
		"OR R1 R2",
		"OR R1 1",
		"XOR R1 R2",
		"XOR R1 1",
		"NOT R1",
		"SHL R1",
		"SHR R1",
		"INC R1",
		"DEC R1",
		"PUSH R1",
		"PUSH 1",
		"POP",
		"POP R1",
		"CMP R1 R2",
		"CMP R1 1",
		"JMP prelabel",
		"JMP postlabel",
		"JMP 5",
		"JMP R1",
		"postlabel:",
		"JE prelabel",
		"JE 5",
		"JE R1",
		"JNE prelabel",
		"JNE 5",
		"JNE R1",
		"JG prelabel",
		"JG 5",
		"JG R1",
		"JGE prelabel",
		"JGE 5",
		"JGE R1",
		"JL prelabel",
		"JL 5",
		"JL R1",
		"JLE prelabel",
		"JLE 5",
		"JLE R1",
		"CALL prelabel",
		"CALL 5",
		"CALL R1",
		"RET",
		"PRINT 1",
		"PRINT R1",
		"PRINTS 10",
		"HLT",
	}

	asm := NewAssembler(program)

	bytecode, err := asm.Assemble()
	if err != nil {
		t.Errorf("Assemble failed: %s", err.Error())
	}

	expected := []uint8{
		uint8(OP_LOAD_RV), 1, 1,
		uint8(OP_LOAD_RR), 1, 2,
		uint8(OP_LOADM_RA), 1, 1,
		uint8(OP_STORE_RA), 1, 1,
		uint8(OP_STORE_AV), 1, 2,
		uint8(OP_STORE_RR), 1, 2,
		uint8(OP_ADD_RR), 1, 2,
		uint8(OP_ADD_RV), 1, 1,
		uint8(OP_SUB_RR), 1, 2,
		uint8(OP_SUB_RV), 1, 1,
		uint8(OP_MUL_RR), 1, 2,
		uint8(OP_MUL_RV), 1, 1,
		uint8(OP_DIV_RR), 1, 2,
		uint8(OP_DIV_RV), 1, 1,
		uint8(OP_MOD_RR), 1, 2,
		uint8(OP_MOD_RV), 1, 1,
		uint8(OP_AND_RR), 1, 2,
		uint8(OP_AND_RV), 1, 1,
		uint8(OP_OR_RR), 1, 2,
		uint8(OP_OR_RV), 1, 1,
		uint8(OP_XOR_RR), 1, 2,
		uint8(OP_XOR_RV), 1, 1,
		uint8(OP_NOT_R), 1,
		uint8(OP_SHL_R), 1,
		uint8(OP_SHR_R), 1,
		uint8(OP_INC_R), 1,
		uint8(OP_DEC_R), 1,
		uint8(OP_PUSH_R), 1,
		uint8(OP_PUSH_V), 1,
		uint8(OP_POP_NONE),
		uint8(OP_POP_R), 1,
		uint8(OP_CMP_RR), 1, 2,
		uint8(OP_CMP_RV), 1, 1,
		uint8(OP_JMP_A), 3 + CodeMemoryStart,
		uint8(OP_JMP_A), 97 + CodeMemoryStart,
		uint8(OP_JMP_A), 5,
		uint8(OP_JMP_R), 1,
		uint8(OP_JE_A), 3 + CodeMemoryStart,
		uint8(OP_JE_A), 5,
		uint8(OP_JE_R), 1,
		uint8(OP_JNE_A), 3 + CodeMemoryStart,
		uint8(OP_JNE_A), 5,
		uint8(OP_JNE_R), 1,
		uint8(OP_JG_A), 3 + CodeMemoryStart,
		uint8(OP_JG_A), 5,
		uint8(OP_JG_R), 1,
		uint8(OP_JGE_A), 3 + CodeMemoryStart,
		uint8(OP_JGE_A), 5,
		uint8(OP_JGE_R), 1,
		uint8(OP_JL_A), 3 + CodeMemoryStart,
		uint8(OP_JL_A), 5,
		uint8(OP_JL_R), 1,
		uint8(OP_JLE_A), 3 + CodeMemoryStart,
		uint8(OP_JLE_A), 5,
		uint8(OP_JLE_R), 1,
		uint8(OP_CALL_A), 3 + CodeMemoryStart,
		uint8(OP_CALL_A), 5,
		uint8(OP_CALL_R), 1,
		uint8(OP_RET_NONE),
		uint8(OP_PRINT_V), 1,
		uint8(OP_PRINT_R), 1,
		uint8(OP_PRINTS_A), 10,
		uint8(OP_HLT_NONE),
	}

	for i, b := range bytecode {
		if b != expected[i] {
			t.Errorf("Expected bytecode at %d to be %d, got %d", i, expected[i], b)
		}
	}
}
